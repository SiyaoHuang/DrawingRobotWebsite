
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Drawing Robot with Single Camera</title>

    <!-- Bootstrap core CSS -->
    <link href="dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <link href="../../assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet"> -->

    <!-- Custom styles for this template -->
    <link href="starter-template.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <!-- <script src="../../assets/js/ie-emulation-modes-warning.js"></script> -->

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Drawing Robot</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#obj">Project Objective</a></li>
            <li><a href="#design">Design and Testing</a></li>
            <li><a href="#result">Results</a></li>
            <li><a href="#conclusion">Conclusions</a></li>
            <li><a href="#future">Future Work</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">

      <div class="starter-template">
        <h1>Drawing Robot</h1>
        <p class="lead">ECE5725 Project<br>A Project By Siyao Huang(sh2435) Daniel Kim(dsk252).</p>
      </div>

      <hr>
      <div class="center-block">
          <iframe width="640" height="360" src="https://www.youtube.com/embed/eiHghX5anlE" frameborder="0" allowfullscreen></iframe>
          <h4 style="text-align:center;">Demonstration Video</h4>
      </div>

      <hr id='obj'>

        <div class="row">
            <div style="text-align:center;">
            <h2>Project Objective</h2>
              <p style="text-align: left;padding: 0px 30px;">Our main objective for this project was to create a robot that could draw pictures accurately by using a camera to track its direction and position. We also wanted the robot to be fairly small so that it would fit comfortably on any size of paper as well as low cost and as simple as possible. Additionally, we wanted to provide users with some sort of interface which would display the current status of the robot as well as show a canvas of some sort on which the user could draw a picture which the robot would then draw on the paper. </p>
            </div>
        </div>
      <hr>

      <hr id="intro">

      <div style="text-align:center;">
              <h2>Introduction</h2>
              <p style="text-align: left;padding: 0px 30px;">Overall, we accomplished our objective: we implemented a small robot that could draw a picture based on input from a user interface. The robot itself has a three servos, two for the wheels and one for moving a pen up and down. The Pi camera tracks the movement of the robot by looking for three colored circles on top of the robot to determine its position and direction and the Raspberry Pi then uses this information to guide the robot from point to point. The camera can be placed (theoretically) in any orientation since we use perspective mapping to determine the 3D position of the robot. Additionally, the bot itself is standalone, requiring no external connections and has its own power supply as well as a Pi Zero. It wirelessly connects with the Raspberry Pi which communicates to the Pi Zero how the robot should move. With this system, the we are able to sketch user drawn shapes onto a paper. </p>
      </div>




    <hr id='design'>

      <div style="text-align:center;">
              <h2>Design</h2>
              <h3>Overview</h3>
              <p style="text-align: left;padding: 0px 30px;">Because our project was fairly complex, we chose to implement standalone modules first, test to ensure the module was working correctly, then move on to implement modules that depended on this module. A high level diagram of the modules as well as the system of our robot can be seen below.</p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 349.33px;"><img alt="" src="images/image28.png" style="width: 624.00px; height: 349.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: A high level diagram of the software. An arrow indicates an import. </span></p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 302.67px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 302.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: High level overview of how software components work together.</span></p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">Our system works by first allowing the user to draw points on the PiTFT. When a point is drawn, it is automatically connected to the previous point with a line. After the user completes the drawing, the controller calibrates the perspective mapping software by having the robot move around in a predetermined fashion. Position of the robot is determined by a camera and three colored dots arranged in a triangle with a fixed distance of 1 inches between the centers of the dots. The drawn array of points is then sent to the controller which guides the robot from point to point, getting input from the perspective mapping software to determine the error in the bot&rsquo;s trajectory and correct accordingly. The controller sends command packets to the Pi Zero (on the robot) via a socket connection to control the robot&rsquo;s movements. Once the points are drawn, the user can decide to draw another picture for the robot to draw or quit the program. Each of these modules is described in detail below. </p>

              <h3>Perspective Mapping</h3>
              <p style="text-align: left;padding: 0px 30px;">The perspective mapping code can be found in the file &lsquo;pmap.py&rsquo; and the main job of this module is to take in 3 points specified by pixel coordinates and convert that into 3D positions in the real world. The way this happens is by using a technique in computer graphics known as ray tracing. Essentially, the scene is modeled by a point for the camera and an image plane in front of the camera. Using this model, a 3D scene of objects can be projected onto the image plane by casting rays from the camera (the beginning point of the ray), through a pixel, and onto the scene where it will hit some object. The color of that object is then projected back onto the pixel. </p>
              <p class="c5 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">Using this technique in reverse, we can cast rays from the camera to the input pixels and determine where the ray intersected the scene. Below is a diagram to make things a bit more clear:</p>
              <p class="c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 313.33px;"><img alt="" src="images/image22.png" style="width: 624.00px; height: 313.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: A simple diagram of ray tracing.</span></p>
              <p class="c5 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">Because we know the distance is fixed between the sides of the triangle as 1 inches, this essentially boils down to a math problem of finding the likeliest length of the 3 rays with the 1 inch constraint. We can use the following equations (note that rays are represented as unit vectors): </p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 251.50px; height: 93.88px;"><img alt="" src="images/image9.png" style="width: 251.50px; height: 93.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p style="text-align: left;padding: 0px 30px;">Our goal is to basically find the </span><span class="c2">ta, tb, <span>and </span><span class="c2">tc</span><span>&nbsp;values that satisfies the above equations. To do this, we implemented a function that sweeps</span><span class="c2">&nbsp;ta</span><span>, calculates the other length values based on this, and selects the</span><span class="c2">&nbsp;ta</span><span class="c0">&nbsp;value that yields a triangle that is closest to an equilateral triangle with side lengths of 1 inches. As it turns out, it is not quite enough to determine the 3D position of a triangle based on only the pixel coordinates: there are two solutions for each case. This is illustrated below: </p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 296.00px;"><img alt="" src="images/image27.png" style="width: 624.00px; height: 296.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: Two possible solutions for the same pixel coordinates.</span></p>
              <p class="c4 c3"><span class="c0"></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 394.50px; height: 367.52px;"><img alt="" src="images/image17.png" style="width: 394.50px; height: 367.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span>Figure x: Graph of sweeping triangles. The y-axis here represents the error in upholding the condition that all triangle side lengths must be 1 inch and the x-axis represents the </span><span class="c2">ta</span><span class="c0">&nbsp;value. Two solutions can be seen where the error is nearly zero at x=~911 and another at x=~940.</span></p>

              <p class="c4 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">Essentially, three points on a screen can be viewed as a triangle that is pointing towards you or a triangle pointing away from you. To figure out which of these was the desired solution, we needed to introduce some sort of calibration that would define the surface our robot was on and pick the triangle that was closest to the plane. Our calibration method takes a set of possible triangles and based on their surface normals, picks the surface normal that is closest to the most triangles in the set. </p>
              <p class="c3 c5"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">After the surface normal is established, future mappings become very easy since we simply need to intersect the rays with the surface to find the triangle. We can then determine the direction of the robot using the position of the three colors at each vertex of the triangle. Additionally, we use the first detected position of the robot as the origin of our coordinate system (which resides on the surface plane) and using the direction, determine plane axis vectors as well. Perspective mapping then becomes a O(1) operation and we simply need to solve the system of equations for ray intersection with the plane. We can then return the position and direction of the robot as 2D vectors. </p>
              <p class="c5 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">One more component required to make this work was to take physical measurements of the setup. We needed to define a conversion factor from pixels to inches as well as measure the distance from the camera to the image plane. To do this, we simply took a picture of a ruler with the Pi camera, measured the distance from the camera to the surface the ruler was sitting on, and got the pixel to inch conversion factor by measuring the length of the ruler in the picture in pixels. The accuracy was not very important because we were mainly concerned with relative distances rather than absolute distances between points. </p>
              <p class="c5 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">After this was completed, we tested by moving a paper on the table with three colored dots in a square in front of the camera and got the following result: </p>
              <p class="c5 c3"><span class="c0"></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 396.50px; height: 299.28px;"><img alt="" src="images/image5.png" style="width: 396.50px; height: 299.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: Perspective mapping, moving in a square.</span></p>

              <h3>Image Processing</h3>
              <p style="text-align: left;padding: 0px 30px;">The image processing code can be found in the file &lsquo;imageprocessor.py&rsquo; and the main role of this module is to determine the position of the three colored dots on the screen in pixel coordinates by using the OpenCV library. To accomplish this, it needs to pick out the three colors reliably and ignore environmental noise that may be a similar color. We considered using LEDs since they are a light source and therefore would not be influenced by environmental factors such as dim lighting, but it turned out to be too bright for the Pi camera to detect as a color. We finally decided to print out 3 colored circles, 1 inch in diameter, on paper and place the paper on top of the robot for the camera to detect. </p>
              <p class="c5 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">Our primary method of picking out the 3 circles was to use thresholding and generate binary images, one for each color. To do this, we specified the hue, saturation, and value ranges for each color and modified this across multiple tests to ensure that it worked for a wide range of environments while also minimizing the amount of noise present. Additionally, we needed to convert the input image from the standard RGB to HSV. Below is a table of the threshold ranges for each of the circles as well as the conversions to HSV:</p>
              <p class="c5 c3"><span class="c0"></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 395.50px; height: 76.69px;"><img alt="" src="images/image10.png" style="width: 395.50px; height: 76.69px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span>Table x: Hue, saturation, and value ranges for thresholding. (Note: hue values range from 0 to 179 while saturation and value range from 0 to 255). </span></p>
              <p class="c5 c3"><span class="c0"></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 346.53px; height: 203.50px;"><img alt="" src="images/image11.png" style="width: 346.53px; height: 203.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: Equations to convert from RGB to HSV</span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 259.35px; height: 199.50px;"><img alt="" src="images/image14.jpg" style="width: 259.35px; height: 199.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 266.05px; height: 204.50px;"><img alt="" src="images/image25.jpg" style="width: 266.05px; height: 204.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: convert actual image from RGB to HSV</span></p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">Much of this was trial and error, first testing for the nominal, well lit case and then moving on to shadowing the circles to see if it still worked. We found that converting to HSV helped a lot because hue would be constant regardless of the lighting conditions. One problem we encountered while testing was that depending on the time of day, there was varying levels of yellow and blue in the environment, namely a lot of blue and yellow that was highly unsaturated. To correct this, we adjusted the saturation so that those values would be cut out of the image. </p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">Once binary images were produced, we needed to first filter out noise and locate the position of the three circles. To filter out noise, we first used OpenCV to find the contours of all the shapes in the binary image, and cut out contours which were below a specified size limit. We were then able to use moments to find the most circular shapes, as shown below: </p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 233.50px; height: 51.79px;"><img alt="" src="images/image8.png" style="width: 243.88px; height: 73.02px; margin-left: 0.00px; margin-top: -10.19px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 229.78px; height: 64.50px;"><img alt="" src="images/image34.png" style="width: 229.78px; height: 64.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 332.50px; height: 54.51px;"><img alt="" src="images/image18.png" style="width: 332.50px; height: 54.51px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: Moment equations</span></p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">We then got the top three candidate circles for the binary images of each color (9 total), looked every possible combination of circles, and selected the group that was most tightly packed (closest together). Once the circles were determined, we again used the moments function to determine the centers of the circles. With this process, we were able to reliably locate the three circles in any lab lighting conditions and return their centers. </p>

              <h3>Wireless Communication</h3>
              <p style="text-align: left;padding: 0px 30px;">The job of the wireless communication module, found in the &lsquo;wireless.py&rsquo; file, is to provide an interface that allows the Pi to communicate to the Pi Zero and remotely control the robot over the WiFi. It does this by establishing a TCP connection via the python socket module. The Pi acts like a server and sends commands as strings via a command code followed by a single argument for that command. The receiver then receives these commands one by one, looks up the command code, and executes the correct function on the actual robot. Below is a table of command codes we used for our robot: </p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 337.24px; height: 198.50px;"><img alt="" src="images/image29.png" style="width: 337.24px; height: 198.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Table x: Commands and their command codes.</span></p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">Additionally, because the receive method of our socket blocked until it received the specified number of bytes causing erratic behavior, we specified a packet size of 50 bytes and executed commands one by one with no buffer (our connection was fast enough that commands were sent almost immediately). Our main concern for this was possible latencies between the server and the robot but because our packets were fairly small, we did not experience any noticeable delays. </p>

              <h3>Bot Controller</h3>
              <p style="text-align: left;padding: 0px 30px;">The job of the robot controller is to provide a library of functions that is able to move the robot in a variety of ways and can be found in the file &lsquo;bot.py&rsquo;. The robot itself is fairly simple, consisting of only 3 continuous rotation servos, two for the wheels and one for moving the pen up and down. </p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">We first created a servo class that encapsulated functionality of a single servo. Our initial implementation consisted of using software PWM to control the servos, but we quickly realized that we needed to control the speed of the servos as accurately as possible. Due to this, we switched over to a hardware PWM implementation which greatly improved robot movement. The bot class provides several functions for moving the </span><span>ro</span><span class="c0">bot and their uses will be further discussed in the main controller section. Below is a table describing each function:</p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 424.50px; height: 249.65px;"><img alt="" src="images/image29.png" style="width: 424.50px; height: 249.65px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Table x: Table showing all functions of the bot class.</span></p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">One of the main issues with the bot was getting the pen to draw reliably and as much in the center of the bot as possible. In our first iteration of the bot, the servo would push the pen down while also pushing the whole bot up so that the wheels were not touching the ground. To fix this, we needed a weight of some sort so we placed a rock on top of our bot to hold it in place. This also provided more friction between the wheels and the paper which improved mobility. Our bot can be seen in the figure below: </p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 274.56px; height: 366.50px;"><img alt="" src="images/image1.jpg" style="width: 274.56px; height: 366.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 273.65px; height: 365.50px;"><img alt="" src="images/image4.jpg" style="width: 273.65px; height: 365.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: Pictures of our bot. The rubber band can be seen on the right and the rock can be seen on the left, providing a weight to hold the pen down.</span></p>

              <h3>Main Controller</h3>
              <p style="text-align: left;padding: 0px 30px;">The main controller (found in the file &lsquo;controller.py&rsquo;) is responsible for using the library functions provided by the image processor, perspective mapping, and wireless bot to guide the robot from point to point. Additionally, the controller contains all of the parameters for bot movement such as servo trimming, error tolerances, bot speed, and so on.</p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">The controller first establishes a wireless connection with the bot, and calls functions that sets up static parameters of the bot including trim values for the left and right servos, pen up and pen down speed, and the length of time spent putting the pen up or down. After this, it starts a calibration routine that basically moves the bot in a predetermined sequence so that the perspective mapping software can determine the surface normal of the plane on which the bot is on. Once completed, the perspective mapping software can identify the position of the bot using the established surface normal and surface axes. The controller then starts the sequence of moving from point to point. A diagram of this process can be seen below:</p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 189.50px; height: 435.94px;"><img alt="" src="images/image24.png" style="width: 189.50px; height: 435.94px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: Main sequence of events to draw from point to point.</span></p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">As shown in Figure x, triangle pixel coordinates are obtained from the image processor which is then passed to the perspective mapping to determine the position and direction of the bot on the surface plane and based on this information, the next movement of the bot is determined. </p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">The movement of the bot was especially difficult since drawing needed to be as accurate as possible. To accomplish a high level of accuracy, we implemented a variety of tweaks: to move to a certain target point, the bot is rotated to within a certain tolerance (fairly large, about 40 degrees) towards the target point and then is rotated thereafter in very small increments until the target direction is reached. We only rotate in one direction since the servos are not perfectly calibrated (since they were both cheap and naturally have small differences in movement speed) and may rotate inaccurately in one direction but accurately in the other. We also increment in small amounts until we have just passed the target direction which we check by looking at the sign of the cross product between the two vectors. Moving forward works the same way where we move the bot forward towards the point to within a certain radius and then move forward in small increments until the target point has been just passed. We check this by looking at the sign of the dot product between the target direction and the bot direction. </p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">Additionally, we implemented a variation of PID control (using just the proportional component) to guide the bot while it covers the distance to the target point to within a certain radius. Our error is based on the angle difference between the bot direction vector and direction vector from the bot to the target point. Based on this error, one of the servos is slowed down slightly while the other is sped up slightly to correct the error. We considered adding in the derivative and integral components but found that using only proportional worked well.</p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 334.50px; height: 280.89px;"><img alt="" src="images/image31.png" style="width: 334.50px; height: 280.89px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: Diagram showing error for proportional control.</span></p>
              <p class="c1 c3"><span class="c0"></span></p>
              <p style="text-align: left;padding: 0px 30px;">One of the main problems we had with the bot was the rate at which it could complete the sequence shown in Figure x: often times, the overhead of the image processing and perspective mapping was enough for the controller to stop the bot later than desired, causing the bot to overshoot the desired location or direction. The reason we used the small rotational and forward adjustments was to correct this problem. We initially tried to decrease the servo speed but found that the slowest speed possible was still too fast for the system to catch it and stop it in time. </p>

              <h3>User Interface</h3>
              <p style="text-align: left;padding: 0px 30px;">The user interface code can be found in the file &ldquo;ui.py&rdquo; and essentially creates a simple interface on the PiTFT for the user to draw shapes. The user can use the 4 buttons to clear the drawing or quit the program (when there are no points), redo, undo, and complete the drawing and start drawing. Points can be placed on the canvas by using the touchscreen of the PiTFT. After the drawing is completed, a point array (of pixel coordinates) is passed to the controller and the bot begins drawing. The UI can be seen below:</p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 247.00px; height: 328.55px;"><img alt="" src="images/image3.jpg" style="width: 247.00px; height: 328.55px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: Picture of the user interface.</span></p>
              <p class="c4 c3"><span class="c0"></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 405.29px; height: 237.50px;"><img alt="" src="images/image2.jpg" style="width: 414.86px; height: 558.45px; margin-left: 0.00px; margin-top: -149.24px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: Another picture of the UI. The clear button changes to a quit button when the canvas is empty.</span></p>
              <p class="c4 c3"><span class="c0"></span></p>
              <p class="c4"><span style="overflow: hidden; display: inline-block; margin: -41.97px 41.97px; border: 0.00px solid #000000; transform: rotate(4.71rad) translateZ(0px); -webkit-transform: rotate(4.71rad) translateZ(0px); width: 248.56px; height: 332.50px;"><img alt="" src="images/image21.jpg" style="width: 248.56px; height: 332.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c4"><span class="c0">Figure x: Side button text disappears after a few seconds of not pressing any buttons.</span></p>

      </div>


    <hr id='result'>

      <div style="text-align:center;">
              <h2>Results</h2>
              <p style="text-align: left;padding: 0px 30px;">Overall, our robot worked as expected: we were able to draw an image on the PiTFT, and have the robot draw a picture with fairly good accuracy, to within an inch of error. The completed robot is shown below:</p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 302.50px; height: 332.20px;"><img alt="" src="images/image1.jpg" style="width: 390.27px; height: 519.01px; margin-left: -13.32px; margin-top: -90.67px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 186.50px; height: 331.56px;"><img alt="" src="images/image30.jpg" style="width: 186.50px; height: 331.56px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span class="c6">Figure x: Completed drawing robot.</span></p>
              <p class="c13"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 285.50px; height: 380.19px;"><img alt="" src="images/image23.jpg" style="width: 285.50px; height: 380.19px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c13"><span class="c6">Figure x: Early sketches of the drawing bot.</span></p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 285.79px; height: 381.50px;"><img alt="" src="images/image4.jpg" style="width: 285.79px; height: 381.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 287.50px; height: 384.45px;"><img alt="" src="images/image13.jpg" style="width: 287.50px; height: 384.45px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span class="c6">Figure x: Underside of the robot, showing the pen and rubber band.</span></p>
              <p style="text-align: left;padding: 0px 30px;">A great deal of time was spent optimizing various components of the robot to increase accuracy. Some of these optimizations include decreasing the resolution of the screen so that more points could be mapped per second, decreasing the packet size from the original size of 1024 bytes to 50 bytes to decrease wireless latency, implementing an O(1) version of the perspective mapping after establishing the surface normal, and tweaking the robot settings such as the speed of the servos as well as applying software trim. Our improvements over time can be seen below:</p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 394.00px; height: 245.00px;"><img alt="" src="images/image26.jpg" style="width: 400.00px; height: 301.00px; margin-left: 0.00px; margin-top: -56.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span class="c6">Figure x: drawing robot keep drawing straight line between two points. Lines on the right side are earliest lines. They gradually evolve to to the lines on the left side.</span></p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 261.00px; height: 342.00px;"><img alt="" src="images/image7.jpg" style="width: 386.00px; height: 515.00px; margin-left: -77.00px; margin-top: -64.00px; transform: rotate(0.51rad) translateZ(0px); -webkit-transform: rotate(0.51rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span class="c6">Figure x: Drawing squares and lines. Accuracy was increased over time, as seen in the lighter square in the back vs the darker square in the front. </span></p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 563.71px; height: 434.50px;"><img alt="" src="images/image33.jpg" style="width: 713.49px; height: 951.33px; margin-left: -54.88px; margin-top: -321.30px; transform: rotate(0.44rad) translateZ(0px); -webkit-transform: rotate(0.44rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 563.50px; height: 315.60px;"><img alt="" src="images/image32.jpg" style="width: 563.50px; height: 315.60px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span class="c6">Figure x: More testing, drawing a variety of shapes. </span></p>
              <p style="text-align: left;padding: 0px 30px;">Our perspective mapping also worked as expected, as seen in a previous figure and worked fairly accurately, to within less than an inch of tolerance:</p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 396.50px; height: 299.28px;"><img alt="" src="images/image5.png" style="width: 396.50px; height: 299.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span class="c6">Figure x: Perspective mapping a square.</span></p>
              <p style="text-align: left;padding: 0px 30px;">Implementing the constant time solution greatly increased the granularity of movements for the robot and improved our controller substantially since it could detect slight movements. Additionally, we were able to sweep triangle distances and select the one with the smallest error. Below is a figure that shows the error as well as the two solutions that intersect the x-axis:</p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 423.50px; height: 395.41px;"><img alt="" src="images/image17.png" style="width: 423.50px; height: 395.41px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span class="c6">Figure x: The y-axis represents the error in the triangles swept out by perspective mapping. As seen here, there are two solutions where the error is zero. </span></p>
              <p style="text-align: left;padding: 0px 30px;">The final implementation of our image processor worked well, effectively ignoring environmental factors such as shadows and highlights, picking out the three colors, and producing binary images:</p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 259.35px; height: 199.50px;"><img alt="" src="images/image14.jpg" style="width: 259.35px; height: 199.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 259.35px; height: 199.50px;"><img alt="" src="images/image25.jpg" style="width: 259.35px; height: 199.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span class="c6">Figure x: On the left is the original image and on the right is an HSV image encoded in RGB. Environmental factors cause highlights, and introduce extra colors such as blue hues in shadows and yellow hues on white surfaces. Red pixels can be seen in the centers of the three circles indicating that the image processor has correctly identified the centers of the circles.</span></p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 195.00px; height: 149.34px;"><img alt="" src="images/image19.jpg" style="width: 195.00px; height: 149.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 196.00px; height: 149.38px;"><img alt="" src="images/image15.jpg" style="width: 196.00px; height: 149.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 194.00px; height: 149.30px;"><img alt="" src="images/image12.jpg" style="width: 194.00px; height: 149.30px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span>Figure x: The three binary images are shown here for yellow, blue, and green respectively. </span></p>
              <p style="text-align: left;padding: 0px 30px;">Below is the final result of the bot. It can handle points that are close together fairly well as well as ones that are far apart. Both triangles begin and end at almost the same location (within less than an inch of tolerance).:</p>
              <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.07px; height: 253.50px;"><img alt="" src="images/image16.jpg" style="width: 433.38px; height: 465.68px; margin-left: -6.95px; margin-top: -118.76px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
              <p class="c1"><span class="c6">Figure x: Some final drawings of the bot.</span></p>
      </div>

    <hr>
    <hr id='conclusion'>
        <div style="text-align:center;">
                <h2>Conclusions</h2>
                <p style="text-align: left;padding: 0px 30px;">Overall, our robot worked as expected. We were able to reliably draw pictures with the camera setup and the user interface. I believe we did everything possible to optimize at the software level and our main limitations at the end were due to the hardware we used to build our robot. Our project mainly consisted of making small, incremental improvements to our software in each of the modules outlined above. For instance, for the bot module, we realized that using hardware PWM greatly improved the granularity in movement of the bot and for perspective mapping, figuring out the constant time solution to find the triangle improved granularity in the bots position and direction. If we were given this project for a second time, we would most likely try to research and invest in better components that would improve accuracy such as an encoder for the servos or camera with better lighting adjustment and resolution.</p>
        </div>
    <hr>
    <hr id='future'>

      <div style="text-align:center;">
              <h2>Future Work</h2>
              <p style="text-align: left;padding: 0px 30px;">The main bottleneck for our bot was the hardware we used. Our servos were very cheap and stopped moving when close to zero speed so much of the solutions we implemented was working around the hardware. Using better servos with a higher granularity of movement would greatly improve movement accuracy. Another limitation was the resolution of our camera. In order to do reduce the latency, we can change the pi camera to a better camera with a higher frame rate to higher resolution images which would allow us to more accurately determine the position and direction of the bot. The final bottleneck is the structure of our code. Changing to a multithreaded design may decrease latency and allow more frames to be processed per second. This is especially useful if we were to use higher resolution images.</p>
              <p style="text-align: left;padding: 0px 30px;">Additionally, WiFi latency was fairly low but there were noticeable jitters when many people were on the network. Using Bluetooth for wireless connection instead of WiFi would possibly be a better solution, but we did not have the time to figure out how to use sockets using Bluetooth so we went with a WiFi connection. Another structural flaw was the mechanism to hold the pen in place. The rubber band that held the pen down would stretch out over the course of a day and start producing different results (e.g. the pen would draw faint lines). Given more time, we would have redesigned the structure to use a spring and move the pen up and down vertically rather than have it rotate down onto the paper like we did.</p>
      </div>

    <hr>
    <div style="font-size:18px">
            <h2>Parts List</h2>
            <p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 523.50px; height: 146.81px;"><img alt="" src="images/image20.png" style="width: 523.50px; height: 146.81px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p>
    </div>

      <div style="font-size:18px">
          <h2>References</h2>
          <a href="https://picamera.readthedocs.io/">PiCamera Document</a><br>
          <a href="http://www.micropik.com/PDF/SG90Servo.pdf">Tower Pro Servo Datasheet</a><br>
          <a href="http://abyz.co.uk/rpi/pigpio/">Pigpio Library</a><br>
          <a href="https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/">R-Pi GPIO Document</a><br>

      </div>

    <hr>

      <div class="row">
              <h2>Code Appendix</h2>
              <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #888888">#Hello ui.py</span>
<span style="color: #008800; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">sys</span><span style="color: #333333">,</span> <span style="color: #0e84b5; font-weight: bold">time</span><span style="color: #333333">,</span> <span style="color: #0e84b5; font-weight: bold">pygame</span>
<span style="color: #008800; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">math</span>
<span style="color: #008800; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">os</span>
<span style="color: #008800; font-weight: bold">import</span> <span style="color: #0e84b5; font-weight: bold">RPi.GPIO</span> <span style="color: #008800; font-weight: bold">as</span> <span style="color: #0e84b5; font-weight: bold">GPIO</span>
<span style="color: #008800; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">controller</span> <span style="color: #008800; font-weight: bold">import</span> <span style="color: #333333">*</span>

os<span style="color: #333333">.</span>putenv(<span style="background-color: #fff0f0">&#39;SDL_VIDEODRIVER&#39;</span>, <span style="background-color: #fff0f0">&#39;fbcon&#39;</span>) <span style="color: #888888"># Display on piTFT</span>
os<span style="color: #333333">.</span>putenv(<span style="background-color: #fff0f0">&#39;SDL_FBDEV&#39;</span>, <span style="background-color: #fff0f0">&#39;/dev/fb1&#39;</span>)
os<span style="color: #333333">.</span>putenv(<span style="background-color: #fff0f0">&#39;SDL_MOUSEDRV&#39;</span>, <span style="background-color: #fff0f0">&#39;TSLIB&#39;</span>)    <span style="color: #888888"># Track mouse clicks</span>
os<span style="color: #333333">.</span>putenv(<span style="background-color: #fff0f0">&#39;SDL_MOUSEDEV&#39;</span>, <span style="background-color: #fff0f0">&#39;/dev/input/touchscreen&#39;</span>)

<span style="color: #888888"># timer</span>
start_time <span style="color: #333333">=</span> time<span style="color: #333333">.</span>time()

<span style="color: #888888"># Initialize GPIO pins</span>
GPIO<span style="color: #333333">.</span>setmode(GPIO<span style="color: #333333">.</span>BCM)
GPIO<span style="color: #333333">.</span>setup(<span style="color: #0000DD; font-weight: bold">17</span>, GPIO<span style="color: #333333">.</span>IN, pull_up_down<span style="color: #333333">=</span>GPIO<span style="color: #333333">.</span>PUD_UP)
GPIO<span style="color: #333333">.</span>setup(<span style="color: #0000DD; font-weight: bold">22</span>, GPIO<span style="color: #333333">.</span>IN, pull_up_down<span style="color: #333333">=</span>GPIO<span style="color: #333333">.</span>PUD_UP)
GPIO<span style="color: #333333">.</span>setup(<span style="color: #0000DD; font-weight: bold">23</span>, GPIO<span style="color: #333333">.</span>IN, pull_up_down<span style="color: #333333">=</span>GPIO<span style="color: #333333">.</span>PUD_UP)
GPIO<span style="color: #333333">.</span>setup(<span style="color: #0000DD; font-weight: bold">27</span>, GPIO<span style="color: #333333">.</span>IN, pull_up_down<span style="color: #333333">=</span>GPIO<span style="color: #333333">.</span>PUD_UP)

pygame<span style="color: #333333">.</span>init()
pygame<span style="color: #333333">.</span>mouse<span style="color: #333333">.</span>set_visible(<span style="color: #007020">True</span>)

size <span style="color: #333333">=</span> width, height <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">320</span>, <span style="color: #0000DD; font-weight: bold">240</span>
black <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #0000DD; font-weight: bold">0</span>
white <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">255</span>, <span style="color: #0000DD; font-weight: bold">255</span>, <span style="color: #0000DD; font-weight: bold">255</span>

screen <span style="color: #333333">=</span> pygame<span style="color: #333333">.</span>display<span style="color: #333333">.</span>set_mode(size)
my_font <span style="color: #333333">=</span> pygame<span style="color: #333333">.</span>font<span style="color: #333333">.</span>Font(<span style="color: #007020">None</span>, <span style="color: #0000DD; font-weight: bold">25</span>)

distance <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">62</span>

sqr_surface <span style="color: #333333">=</span> my_font<span style="color: #333333">.</span>render(<span style="background-color: #fff0f0">&quot;Clear&quot;</span>, <span style="color: #007020">True</span>, black)
sqr_pos <span style="color: #333333">=</span> sqr_x, left_y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">290</span>, <span style="color: #0000DD; font-weight: bold">40</span>
sqr_rect <span style="color: #333333">=</span> sqr_surface<span style="color: #333333">.</span>get_rect(center<span style="color: #333333">=</span>sqr_pos)

sq_surface <span style="color: #333333">=</span> my_font<span style="color: #333333">.</span>render(<span style="background-color: #fff0f0">&quot;Quit&quot;</span>, <span style="color: #007020">True</span>, black)
sq_rect <span style="color: #333333">=</span> sq_surface<span style="color: #333333">.</span>get_rect(center<span style="color: #333333">=</span>sqr_pos)

done_surface <span style="color: #333333">=</span> my_font<span style="color: #333333">.</span>render(<span style="background-color: #fff0f0">&quot;Done&quot;</span>, <span style="color: #007020">True</span>, black)
done_pos <span style="color: #333333">=</span> done_x, done_y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">290</span>, <span style="color: #0000DD; font-weight: bold">40</span> <span style="color: #333333">+</span> distance
done_rect <span style="color: #333333">=</span> done_surface<span style="color: #333333">.</span>get_rect(center<span style="color: #333333">=</span>done_pos)

undo_surface <span style="color: #333333">=</span> my_font<span style="color: #333333">.</span>render(<span style="background-color: #fff0f0">&quot;Undo&quot;</span>, <span style="color: #007020">True</span>, black)
undo_pos <span style="color: #333333">=</span> undo_x, undo_y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">290</span>, <span style="color: #0000DD; font-weight: bold">40</span> <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">2</span><span style="color: #333333">*</span>distance
undo_rect <span style="color: #333333">=</span> undo_surface<span style="color: #333333">.</span>get_rect(center<span style="color: #333333">=</span>undo_pos)

redo_surface <span style="color: #333333">=</span> my_font<span style="color: #333333">.</span>render(<span style="background-color: #fff0f0">&quot;Redo&quot;</span>, <span style="color: #007020">True</span>, black)
redo_pos <span style="color: #333333">=</span> redo_x, redo_y <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">290</span>, <span style="color: #0000DD; font-weight: bold">40</span> <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">3</span><span style="color: #333333">*</span>distance
redo_rect <span style="color: #333333">=</span> redo_surface<span style="color: #333333">.</span>get_rect(center<span style="color: #333333">=</span>redo_pos)

show_buttons <span style="color: #333333">=</span> <span style="color: #007020">True</span>
points <span style="color: #333333">=</span> []
pointsredo <span style="color: #333333">=</span> []
start <span style="color: #333333">=</span> time<span style="color: #333333">.</span>time()
c <span style="color: #333333">=</span> Controller()
timer <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>
<span style="color: #008800; font-weight: bold">while</span> <span style="color: #007020">True</span>:
	<span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> GPIO<span style="color: #333333">.</span>input(<span style="color: #0000DD; font-weight: bold">17</span>):
                <span style="color: #008800; font-weight: bold">if</span> points <span style="color: #333333">==</span> []:
                    <span style="color: #008800; font-weight: bold">break</span>
		points <span style="color: #333333">=</span> []
		pointsredo <span style="color: #333333">=</span> []
		time<span style="color: #333333">.</span>sleep(<span style="color: #6600EE; font-weight: bold">0.2</span>)
	<span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> GPIO<span style="color: #333333">.</span>input(<span style="color: #0000DD; font-weight: bold">22</span>):
		c<span style="color: #333333">.</span>drawPoints(points[::<span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>])
	<span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> GPIO<span style="color: #333333">.</span>input(<span style="color: #0000DD; font-weight: bold">23</span>):
		<span style="color: #008800; font-weight: bold">if</span> points <span style="color: #333333">!=</span> []:
			pointsredo <span style="color: #333333">=</span> [points[<span style="color: #0000DD; font-weight: bold">0</span>]] <span style="color: #333333">+</span> pointsredo
			<span style="color: #008800; font-weight: bold">del</span> points[<span style="color: #0000DD; font-weight: bold">0</span>]
		time<span style="color: #333333">.</span>sleep(<span style="color: #6600EE; font-weight: bold">0.2</span>)
	<span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> GPIO<span style="color: #333333">.</span>input(<span style="color: #0000DD; font-weight: bold">27</span>):
		<span style="color: #008800; font-weight: bold">if</span> pointsredo <span style="color: #333333">!=</span> []:
			points <span style="color: #333333">=</span> [pointsredo[<span style="color: #0000DD; font-weight: bold">0</span>]] <span style="color: #333333">+</span> points
			<span style="color: #008800; font-weight: bold">del</span> pointsredo[<span style="color: #0000DD; font-weight: bold">0</span>]
		time<span style="color: #333333">.</span>sleep(<span style="color: #6600EE; font-weight: bold">0.2</span>)
	<span style="color: #008800; font-weight: bold">for</span> event <span style="color: #000000; font-weight: bold">in</span> pygame<span style="color: #333333">.</span>event<span style="color: #333333">.</span>get():
		<span style="color: #008800; font-weight: bold">if</span> event<span style="color: #333333">.</span>type <span style="color: #333333">==</span> pygame<span style="color: #333333">.</span>QUIT:
			sys<span style="color: #333333">.</span>exit()
		<span style="color: #008800; font-weight: bold">if</span> event<span style="color: #333333">.</span>type <span style="color: #333333">==</span> pygame<span style="color: #333333">.</span>MOUSEBUTTONUP:
			show_buttons <span style="color: #333333">=</span> <span style="color: #007020">False</span>
			timer <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">100</span>
			x, y <span style="color: #333333">=</span> pygame<span style="color: #333333">.</span>mouse<span style="color: #333333">.</span>get_pos()
			dist <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">20</span>
			<span style="color: #008800; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">in</span> points:
				xi, yi <span style="color: #333333">=</span> i
				<span style="color: #008800; font-weight: bold">if</span> ((xi <span style="color: #333333">-</span> x)<span style="color: #333333">**</span><span style="color: #0000DD; font-weight: bold">2</span> <span style="color: #333333">+</span> (yi <span style="color: #333333">-</span> y)<span style="color: #333333">**</span><span style="color: #0000DD; font-weight: bold">2</span>)<span style="color: #333333">**.</span><span style="color: #0000DD; font-weight: bold">5</span> <span style="color: #333333">&lt;</span> dist:
					x, y <span style="color: #333333">=</span> xi, yi
					<span style="color: #008800; font-weight: bold">break</span>
			points <span style="color: #333333">=</span> [(x, y)] <span style="color: #333333">+</span> points
			pointsredo <span style="color: #333333">=</span> []
			<span style="color: #008800; font-weight: bold">print</span> x, y

	<span style="color: #008800; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">not</span> show_buttons:
		<span style="color: #008800; font-weight: bold">if</span> timer <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">0</span>:
			show_buttons <span style="color: #333333">=</span> <span style="color: #007020">True</span>
		timer <span style="color: #333333">-=</span> <span style="color: #0000DD; font-weight: bold">1</span>

	screen<span style="color: #333333">.</span>fill(white)
	<span style="color: #008800; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">in</span> points:
		pygame<span style="color: #333333">.</span>draw<span style="color: #333333">.</span>circle(screen, black, i, <span style="color: #0000DD; font-weight: bold">2</span>)
	<span style="color: #008800; font-weight: bold">if</span> <span style="color: #007020">len</span>(points) <span style="color: #333333">&gt;</span> <span style="color: #0000DD; font-weight: bold">1</span>:
		pygame<span style="color: #333333">.</span>draw<span style="color: #333333">.</span>lines(screen, black, <span style="color: #007020">False</span>, points, <span style="color: #0000DD; font-weight: bold">2</span>)

	<span style="color: #008800; font-weight: bold">if</span> show_buttons:
                <span style="color: #008800; font-weight: bold">if</span> points <span style="color: #333333">==</span> []:
                        screen<span style="color: #333333">.</span>blit(sq_surface, sq_rect)
                <span style="color: #008800; font-weight: bold">else</span>:
		        screen<span style="color: #333333">.</span>blit(sqr_surface, sqr_rect)
		screen<span style="color: #333333">.</span>blit(done_surface, done_rect)
		screen<span style="color: #333333">.</span>blit(undo_surface, undo_rect)
		screen<span style="color: #333333">.</span>blit(redo_surface, redo_rect)
	pygame<span style="color: #333333">.</span>display<span style="color: #333333">.</span>flip()

	time<span style="color: #333333">.</span>sleep(<span style="color: #6600EE; font-weight: bold">0.01</span>)

GPIO<span style="color: #333333">.</span>cleanup()
sys<span style="color: #333333">.</span>exit()
</pre></td></tr></table></div>

      </div>





    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
    <script src="dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script> -->
  </body>
</html>
